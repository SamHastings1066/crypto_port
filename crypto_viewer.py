import streamlit as st
import requests
import json
import plotly.express as px
import pandas as pd
import datetime as dt
import glob
import base64

def load_data(limit='10'):
  '''
  Returns a dictionary with data for each of the top 'limit' cypto currencies
  ranked by market cap. The data is generated by querying the coincap API
  /assets endpoint. See coincap documentation for more info:
  https://docs.coincap.io/

  Parameters:
    limit (str): The number of crypto coins that you want to return data for.
      Ranked in order of market cap.

  Returns:
    (dict): A dictionary object of data.

  '''
  url = "https://api.coincap.io/v2/assets"
  # N.B. here adampt the params dict to only request what you need
  payload={'limit': limit}
  headers = {}
  return requests.request("GET", url, params=payload, headers=headers).json()

def load_histories(ids_list):
  url = "http://api.coincap.io/v2/assets/{}/history?interval=d1"

  payload={}
  headers = {}

  histories_dict = {}
  for id in ids_list:
      response_histories = requests.request("GET", url.format(id), headers=headers, data=payload)
      histories_json = response_histories.json()
      histories_dict[id] = histories_json['data']
  return histories_dict


def gen_symbols(assets_json):
  symbols_list = []
  names_list = []
  ids_list =[]
  for dict in assets_json['data']:
    symbols_list.append(dict['symbol'])
    names_list.append(dict['name'])
    ids_list.append(dict['id'])
  return symbols_list, names_list, ids_list

def write_symbols(symbols_list):
    cols = st.columns(len(symbols_list))
    for i, symbol in enumerate(symbols_list):
      col = cols[i]
      col.image(f'logos/{symbol}.png',width=40)
      globals()[st.session_state.names[i]] = col.checkbox(symbol, value = 0)
      #col.checkbox(symbol, st.image(f'logos/{symbol}.png',width=40))

if "assets_json" not in st.session_state:
  st.session_state.assets_json = load_data()
  symbols, names, ids = gen_symbols(st.session_state.assets_json)
  st.session_state.symbols = symbols
  st.session_state.names = names
  st.session_state.ids = ids
  st.session_state.histories = load_histories(ids)


#write_symbols(st.session_state.symbols)
symbols_list = st.session_state.symbols
names_list = st.session_state.names
ids_list = st.session_state.ids
asset_json = st.session_state.assets_json
histories_dict = st.session_state.histories


def date_conv(date):
    return dt.datetime.strptime(date, '%Y-%m-%d')
price_histories_df = pd.DataFrame(columns=['coin','date','price'])
return_histories_df = pd.DataFrame(columns=['coin','date','price'])
for id in ids_list:
    price=[]
    date=[]
    for observation in histories_dict[id]:
        date.append(date_conv(observation['date'][0:10]))
        #date.append(observation['time'])
        price.append(float(observation['priceUsd']))
    price_df = pd.DataFrame({"coin": id, "date":date, "price": price})
    price_histories_df = pd.concat([price_histories_df, price_df])
    returns = [float(b) / float(a) for b,a in zip(price[1:], price[:-1])]
    returns_df = pd.DataFrame({"coin": id, "date":date[1:], "price": returns})
    return_histories_df = pd.concat([return_histories_df, returns_df])



start_date = dt.date.today()-dt.timedelta(360)
rebased_prices_df = pd.DataFrame(columns=['coin','date','price','rebased_price'])
for id in ids_list:
    temp_rebase_df = return_histories_df[(return_histories_df['date']>=pd.Timestamp(start_date))
                                         & (return_histories_df['coin']==id)]
    rebased_price=[1]
    for i in range(1,len(temp_rebase_df)):
        rebased_price.append(temp_rebase_df['price'].iloc[i]*rebased_price[i-1])
    temp_rebase_df['rebased_price']=rebased_price
    rebased_prices_df = pd.concat([rebased_prices_df, temp_rebase_df])

fig2 = px.line(rebased_prices_df, x="date", y="rebased_price", color="coin")
st.write(fig2)
cols = st.columns(len(symbols_list))
checkboxes=[]
for i, symbol in enumerate(symbols_list):
  col = cols[i]
  col.image(f'logos/{symbol}.png',width=40)
  globals()[st.session_state.names[i]] = col.checkbox(symbol, value = 0)
  checkboxes.append(globals()[st.session_state.names[i]])






if any(checkboxes):
  checked_ids=[]
  cols2 = st.columns(sum(checkboxes))
  j=0
  for i, value in enumerate(checkboxes):
    if value==1:
      checked_ids.append(ids_list[i])
      col2=cols2[j]
      col2.image(f'logos/{symbols_list[i]}.png',width=20)
      j+=1

st.image('images/result.png', width=360)

gen_port = st.button('Generate portfolio return')

if gen_port:
  weights = [1/len(checked_ids)]*len(checked_ids)
  portfolio_dict={checked_ids[i]:weights[i] for i in range(len(checked_ids))}
  start_date = dt.date.today()-dt.timedelta(360)
  weighted_prices_df = pd.DataFrame(columns=['coin','date','price','weighted_price'])
  for id in checked_ids:
    temp_weight_df = return_histories_df[(return_histories_df['date']>=pd.Timestamp(start_date))
                                        & (return_histories_df['coin']==id)]
    weighted_price=[portfolio_dict[id]]
    for i in range(1,len(temp_weight_df)):
      weighted_price.append(temp_weight_df['price'].iloc[i]*weighted_price[i-1])
    temp_weight_df['weighted_price']=weighted_price
    weighted_prices_df = pd.concat([weighted_prices_df, temp_weight_df])
  date_list = [start_date + dt.timedelta(days=x) for x in range(360)]
  port_returns=[]
  for date in date_list:
    port_returns.append(weighted_prices_df['weighted_price'][weighted_prices_df['date']==pd.Timestamp(date)].sum())
  port_returns_df = pd.DataFrame({'date':date_list, 'price': port_returns})
  fig3 = px.line(port_returns_df, x="date", y="price")
  st.write(fig3)


  #for i, symbol in enumerate(symbols_list):
  #  col2 = cols2[i]
  #  col.image(f'logos/{symbol}.png',width=40)
  #price_subset_df = price_histories_df[price_histories_df['coin'].isin(checked_ids)]
  #rebased_subset_df = rebased_prices_df[rebased_prices_df['coin'].isin(checked_ids)]
  #fig1 = px.line(price_subset_df, x="date", y="price", color="coin")
  #st.write(fig1)
  #fig2 = px.line(rebased_subset_df, x="date", y="rebased_price", color="coin")
  #st.write(fig2)







